#include "normal_deform_factors.h"

#include <igl/per_face_normals.h>
#include <igl/doublearea.h>
#include <igl/internal_angles.h> 



//template <typename DerivedV, typename DerivedF>
//IGL_INLINE void per_vertex_normals(
//  const Eigen::PlainObjectBase<DerivedV>& V,
//  const Eigen::PlainObjectBase<DerivedF>& F,
//  const igl::PerVertexNormalsWeightingType weighting,
//  Eigen::PlainObjectBase<DerivedV> & N)
//{
//  Eigen::PlainObjectBase<DerivedV> PFN;
//  igl::per_face_normals(V,F,PFN);
//  return per_vertex_normals(V,F,weighting,PFN,N);
//}
//
//template <typename DerivedV, typename DerivedF>
//IGL_INLINE void per_vertex_normals(
//  const Eigen::PlainObjectBase<DerivedV>& V,
//  const Eigen::PlainObjectBase<DerivedF>& F,
//  Eigen::PlainObjectBase<DerivedV> & N)
//{
//  return per_vertex_normals(V,F,PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT,N);
//}
//
//template <typename DerivedV, typename DerivedF>
//IGL_INLINE void per_vertex_normals(
//  const Eigen::PlainObjectBase<DerivedV>& V,
//  const Eigen::PlainObjectBase<DerivedF>& F,
//  const igl::PerVertexNormalsWeightingType weighting,
//  const Eigen::PlainObjectBase<DerivedV>& FN,
//  Eigen::PlainObjectBase<DerivedV> & N)
//{
//  // Resize for output
//  N.setZero(V.rows(),3);
//
//  Eigen::MatrixXd W(F.rows(),3);
//  switch(weighting)
//  {
//    case PER_VERTEX_NORMALS_WEIGHTING_TYPE_UNIFORM:
//      W.setConstant(1.);
//      break;
//    default:
//      assert(false && "Unknown weighting type");
//    case PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT:
//    case PER_VERTEX_NORMALS_WEIGHTING_TYPE_AREA:
//    {
//      Eigen::VectorXd A;
//      doublearea(V,F,A);
//      W = A.replicate(1,3);
//      break;
//    }
//    case PER_VERTEX_NORMALS_WEIGHTING_TYPE_ANGLE:
//      internal_angles(V,F,W);
//      break;
//  }
//
//  // loop over faces
//  const int Frows = F.rows();
////// Minimum number of iterms per openmp thread
////#ifndef IGL_OMP_MIN_VALUE
////#  define IGL_OMP_MIN_VALUE 1000
////#endif
////#pragma omp parallel for if (Frows>IGL_OMP_MIN_VALUE)
//  for(int i = 0; i < Frows;i++)
//  {
//    // throw normal at each corner
//    for(int j = 0; j < 3;j++)
//    {
//      // Does this need to be critical?
////#pragma omp critical
//      N.row(F(i,j)) += W(i,j)*FN.row(i);
//    }
//  }
//  // take average via normalization
//  N.rowwise().normalize();
//}
//
//template <typename DerivedV, typename DerivedF>
//IGL_INLINE void per_vertex_normals(
//  const Eigen::PlainObjectBase<DerivedV>& V,
//  const Eigen::PlainObjectBase<DerivedF>& F,
//  const Eigen::PlainObjectBase<DerivedV>& FN,
//  Eigen::PlainObjectBase<DerivedV> & N)
//{
//  return
//    per_vertex_normals(V,F,PER_VERTEX_NORMALS_WEIGHTING_TYPE_DEFAULT,FN,N);
//}

#ifndef IGL_HEADER_ONLY

//// Explicit template specialization
//// generated by autoexplicit.sh
//template void igl::per_vertex_normals<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, igl::PerVertexNormalsWeightingType, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&);
//// generated by autoexplicit.sh
//template void igl::per_vertex_normals<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&);
//template void igl::per_vertex_normals<Eigen::Matrix<double, -1, 3, 1, -1, 3>, Eigen::Matrix<unsigned int, -1, -1, 1, -1, -1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 1, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<unsigned int, -1, -1, 1, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 1, -1, 3> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 3, 1, -1, 3> >&);
//template void igl::per_vertex_normals<Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&);






//template <typename DerivedV, typename DerivedF>
//IGL_INLINE void per_vertex_normals(
//  const Eigen::PlainObjectBase<DerivedV>& V,
//  const Eigen::PlainObjectBase<DerivedF>& F,
//  const Eigen::PlainObjectBase<DerivedV>& FN,
//  Eigen::PlainObjectBase<DerivedV> & N);

//template void igl::per_vertex_normals<	Eigen::Matrix<double, -1, -1, 0, -1, -1>, 
//										Eigen::Matrix<int, -1, -1, 0, -1, -1> >
//(
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&
//);


//template void normal_deform_factors<
//									Eigen::Matrix<double, -1, -1, 0, -1, -1>, 
//									Eigen::Matrix<int, -1, -1, 0, -1, -1>,
//									Eigen::Matrix<double, -1, -1, 0, -1, -1>,
//									Eigen::Matrix<double, -1, -1, 0, -1, -1>,
//									Eigen::Matrix<double, -1, -1, 0, -1, -1>
//									>
//(
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> > const&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&, 
//	Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&
//);

//template  void normal_deform_factors(
//	const Eigen::PlainObjectBase<DerivedV>& V,
//	const Eigen::PlainObjectBase<DerivedF>& F,
//	const Eigen::PlainObjectBase<DerivedV>& Normals_vertex0,//N,//Normals per vertex at rest pose.
//	const Eigen::PlainObjectBase<DerivedV>& Normals_face0,//NF,//Normals per face at rest pose.
//	const Eigen::PlainObjectBase<DerivedW>& Weights,//W,
//	Eigen::PlainObjectBase<DerivedV>& t_dir,//Tangents,
//	Eigen::PlainObjectBase<DerivedV>& b_dir,//Binormals
//	Eigen::PlainObjectBase<DerivedW>& alphaFactors,
//	Eigen::PlainObjectBase<DerivedW>& betaFactors);

#endif
